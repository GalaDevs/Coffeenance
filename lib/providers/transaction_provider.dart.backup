import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/transaction.dart';
import '../services/firestore_service.dart';

/// TransactionProvider manages all transaction state
/// Replaces Next.js useState for transactions management
/// Persists to both local storage (SharedPreferences) and Cloud Firestore
class TransactionProvider with ChangeNotifier {
  final FirestoreService _firestoreService = FirestoreService();
  List<Transaction> _transactions = [];
  bool _isLoading = false;
  bool _useFirestore = true; // Toggle to enable/disable Firestore sync
  
  // Inventory management
  List<Map<String, dynamic>> _inventory = [];
  
  // Staff/Payroll management
  List<Map<String, dynamic>> _staff = [];
  
  // KPI Settings and Targets
  Map<String, dynamic> _kpiSettings = {};
  
  // Tax Settings
  Map<String, dynamic> _taxSettings = {};

  // Getters
  List<Transaction> get transactions => List.unmodifiable(_transactions);
  bool get isLoading => _isLoading;
  List<Map<String, dynamic>> get inventory => List.unmodifiable(_inventory);
  List<Map<String, dynamic>> get staff => List.unmodifiable(_staff);
  Map<String, dynamic> get kpiSettings => Map.unmodifiable(_kpiSettings);
  Map<String, dynamic> get taxSettings => Map.unmodifiable(_taxSettings);

  // Computed properties matching Next.js logic
  List<Transaction> get revenueTransactions =>
      _transactions.where((t) => t.type == TransactionType.revenue).toList();

  List<Transaction> get transactionList =>
      _transactions.where((t) => t.type == TransactionType.transaction).toList();

  List<Transaction> get transactionRecords => transactionList; // Alias

  double get totalRevenue =>
      revenueTransactions.fold(0.0, (sum, t) => sum + t.amount);

  double get totalTransaction =>
      transactionList.fold(0.0, (sum, t) => sum + t.amount);

  double get balance => totalRevenue - totalTransaction;

  // Backward compatibility aliases
  double get totalIncome => totalRevenue;
  double get totalExpense => totalTransaction;
  double get totalTransactions => totalTransaction; // Plural alias
  Map<String, double> get salesByMethod => revenueByMethod;
  Map<String, double> get expensesByCategory => transactionsByCategory;

  /// Get revenue breakdown by payment method (matching Next.js revenueByMethod)
  Map<String, double> get revenueByMethod {
    return {
      RevenueCategories.cash: revenueTransactions
          .where((t) => t.category == RevenueCategories.cash)
          .fold(0.0, (sum, t) => sum + t.amount),
      RevenueCategories.gcash: revenueTransactions
          .where((t) => t.category == RevenueCategories.gcash)
          .fold(0.0, (sum, t) => sum + t.amount),
      RevenueCategories.grab: revenueTransactions
          .where((t) => t.category == RevenueCategories.grab)
          .fold(0.0, (sum, t) => sum + t.amount),
      RevenueCategories.paymaya: revenueTransactions
          .where((t) => t.category == RevenueCategories.paymaya)
          .fold(0.0, (sum, t) => sum + t.amount),
      RevenueCategories.others: revenueTransactions
          .where((t) => t.category == RevenueCategories.others)
          .fold(0.0, (sum, t) => sum + t.amount),
    };
  }

  /// Get transactions breakdown by category
  Map<String, double> get transactionsByCategory {
    return {
      TransactionCategories.supplies: transactionList
          .where((t) => t.category == TransactionCategories.supplies)
          .fold(0.0, (sum, t) => sum + t.amount),
      TransactionCategories.pastries: transactionList
          .where((t) => t.category == TransactionCategories.pastries)
          .fold(0.0, (sum, t) => sum + t.amount),
      TransactionCategories.rent: transactionList
          .where((t) => t.category == TransactionCategories.rent)
          .fold(0.0, (sum, t) => sum + t.amount),
      TransactionCategories.utilities: transactionList
          .where((t) => t.category == TransactionCategories.utilities)
          .fold(0.0, (sum, t) => sum + t.amount),
      TransactionCategories.manpower: transactionList
          .where((t) => t.category == TransactionCategories.manpower)
          .fold(0.0, (sum, t) => sum + t.amount),
      TransactionCategories.marketing: transactionList
          .where((t) => t.category == TransactionCategories.marketing)
          .fold(0.0, (sum, t) => sum + t.amount),
      TransactionCategories.others: transactionList
          .where((t) => t.category == TransactionCategories.others)
          .fold(0.0, (sum, t) => sum + t.amount),
    };
  }

  TransactionProvider() {
    _loadInitialData();
    _loadInventoryData();
    _loadStaffData();
    _loadKPISettings();
    _loadTaxSettings();
    
    // Set up Firestore listeners if enabled
    if (_useFirestore) {
      _setupFirestoreListeners();
    }
  }

  /// Set up real-time listeners for Firestore data
  void _setupFirestoreListeners() {
    // Listen to transactions
    _firestoreService.getTransactionsStream().listen((transactions) {
      _transactions = transactions;
      notifyListeners();
      _saveToStorage(); // Also save to local storage for offline access
    });

    // Listen to inventory
    _firestoreService.getInventoryStream().listen((inventory) {
      _inventory = inventory;
      notifyListeners();
      _saveInventoryToStorage();
    });

    // Listen to staff
    _firestoreService.getStaffStream().listen((staff) {
      _staff = staff;
      notifyListeners();
      _saveStaffToStorage();
    });
  }

  /// Load initial inventory data
  Future<void> _loadInventoryData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final String? inventoryJson = prefs.getString('inventory');

      if (inventoryJson != null) {
        final List<dynamic> decoded = json.decode(inventoryJson);
        _inventory = decoded.cast<Map<String, dynamic>>();
      } else {
        // Sample inventory data
        _inventory = [
          {'item': 'Coffee Beans', 'stock': 45, 'unit': 'kg', 'status': 'good', 'reorder': 30},
          {'item': 'Milk', 'stock': 12, 'unit': 'L', 'status': 'warning', 'reorder': 20},
          {'item': 'Sugar', 'stock': 8, 'unit': 'kg', 'status': 'critical', 'reorder': 15},
          {'item': 'Pastry Dough', 'stock': 25, 'unit': 'kg', 'status': 'good', 'reorder': 20},
          {'item': 'Cups (12oz)', 'stock': 200, 'unit': 'pcs', 'status': 'good', 'reorder': 500},
          {'item': 'Napkins', 'stock': 80, 'unit': 'pcs', 'status': 'warning', 'reorder': 200},
        ];
        await _saveInventoryToStorage();
      }
    } catch (e) {
      debugPrint('Error loading inventory: $e');
    }
  }

  /// Load initial staff data
  Future<void> _loadStaffData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final String? staffJson = prefs.getString('staff');

      if (staffJson != null) {
        final List<dynamic> decoded = json.decode(staffJson);
        _staff = decoded.cast<Map<String, dynamic>>();
      } else {
        // Sample staff data
        _staff = [
          {'id': 1, 'name': 'Maria Santos', 'position': 'Manager', 'salary': 25000.0, 'status': 'Full-time', 'startDate': '2023-01'},
          {'id': 2, 'name': 'Juan Dela Cruz', 'position': 'Barista', 'salary': 18000.0, 'status': 'Full-time', 'startDate': '2023-06'},
          {'id': 3, 'name': 'Rosa Garcia', 'position': 'Cashier', 'salary': 16000.0, 'status': 'Full-time', 'startDate': '2023-09'},
          {'id': 4, 'name': 'Pedro Lim', 'position': 'Barista', 'salary': 18000.0, 'status': 'Full-time', 'startDate': '2024-01'},
          {'id': 5, 'name': 'Anna Wong', 'position': 'Part-time Staff', 'salary': 12000.0, 'status': 'Part-time', 'startDate': '2024-03'},
        ];
        await _saveStaffToStorage();
      }
    } catch (e) {
      debugPrint('Error loading staff: $e');
    }
  }

  /// Load initial sample data matching Next.js initial state
  Future<void> _loadInitialData() async {
    _isLoading = true;
    notifyListeners();

    try {
      // Try to load from SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      final String? transactionsJson = prefs.getString('transactions');

      if (transactionsJson != null) {
        final List<dynamic> decoded = json.decode(transactionsJson);
        _transactions = decoded.map((json) => Transaction.fromJson(json)).toList();
      } else {
        // Load sample data matching Next.js initial state
        _transactions = [
          Transaction(
            id: 1,
            date: DateTime.now().toIso8601String().split('T')[0],
            type: TransactionType.revenue,
            category: RevenueCategories.cash,
            description: 'Cash sales',
            amount: 450.0,
            paymentMethod: 'Cash',
            transactionNumber: 'TXN001',
            receiptNumber: 'RCP001',
          ),
          Transaction(
            id: 2,
            date: DateTime.now().subtract(const Duration(days: 1)).toIso8601String().split('T')[0],
            type: TransactionType.revenue,
            category: RevenueCategories.gcash,
            description: 'GCash payment',
            amount: 280.0,
            paymentMethod: 'GCash',
            transactionNumber: 'TXN002',
            receiptNumber: 'RCP002',
          ),
          Transaction(
            id: 3,
            date: DateTime.now().subtract(const Duration(days: 1)).toIso8601String().split('T')[0],
            type: TransactionType.transaction,
            category: TransactionCategories.supplies,
            description: 'Coffee beans',
            amount: 150.0,
            paymentMethod: 'Cash',
            transactionNumber: 'TXN003',
            receiptNumber: 'RCP003',
            supplierName: 'Coffee Supplier Inc.',
            vat: 12,
          ),
        ];
        await _saveToStorage();
      }
    } catch (e) {
      debugPrint('Error loading transactions: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Add transaction (matching Next.js handleAddTransaction)
  Future<void> addTransaction(Transaction transaction) async {
    // Generate new ID
    final int newId = _transactions.isEmpty
        ? 1
        : _transactions.map((t) => t.id).reduce((a, b) => a > b ? a : b) + 1;

    final newTransaction = transaction.copyWith(
      id: newId,
      date: DateTime.now().toIso8601String().split('T')[0],
    );

    // Add to Firestore if enabled
    if (_useFirestore) {
      try {
        await _firestoreService.addTransaction(newTransaction);
        // Firestore listener will update local state
      } catch (e) {
        debugPrint('Error adding to Firestore: $e');
        // Fall back to local-only
        _transactions.insert(0, newTransaction);
        notifyListeners();
        await _saveToStorage();
      }
    } else {
      // Add to beginning of list (matching Next.js behavior)
      _transactions.insert(0, newTransaction);
      notifyListeners();
      await _saveToStorage();
    }
  }     ];
        await _saveToStorage();
      }
    } catch (e) {
      debugPrint('Error loading transactions: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Add transaction (matching Next.js handleAddTransaction)
  Future<void> addTransaction(Transaction transaction) async {
    // Generate new ID
    final int newId = _transactions.isEmpty
        ? 1
        : _transactions.map((t) => t.id).reduce((a, b) => a > b ? a : b) + 1;

    final newTransaction = transaction.copyWith(
  /// Delete transaction
  Future<void> deleteTransaction(int id) async {
    if (_useFirestore) {
      try {
        // Find the transaction to get its Firestore document ID
        final transaction = _transactions.firstWhere((t) => t.id == id);
        if (transaction.firestoreId != null) {
          await _firestoreService.deleteTransaction(transaction.firestoreId!);
          // Firestore listener will update local state
        }
      } catch (e) {
        debugPrint('Error deleting from Firestore: $e');
        // Fall back to local-only
        _transactions.removeWhere((t) => t.id == id);
        notifyListeners();
        await _saveToStorage();
      }
    } else {
      _transactions.removeWhere((t) => t.id == id);
      notifyListeners();
      await _saveToStorage();
    }
  } _transactions.insert(0, newTransaction);
    notifyListeners();

    // Persist to storage
    await _saveToStorage();
  }

  /// Delete transaction
  Future<void> deleteTransaction(int id) async {
    _transactions.removeWhere((t) => t.id == id);
    notifyListeners();
    await _saveToStorage();
  }

  /// Update transaction
  Future<void> updateTransaction(Transaction transaction) async {
    final index = _transactions.indexWhere((t) => t.id == transaction.id);
    if (index != -1) {
      _transactions[index] = transaction;
      notifyListeners();
      await _saveToStorage();
    }
  }

  /// Clear all transactions
  Future<void> clearAll() async {
    _transactions.clear();
    notifyListeners();
    await _saveToStorage();
  }

  /// Save transactions to SharedPreferences (localStorage equivalent)
  Future<void> _saveToStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final List<Map<String, dynamic>> jsonList =
          _transactions.map((t) => t.toJson()).toList();
      await prefs.setString('transactions', json.encode(jsonList));
    } catch (e) {
      debugPrint('Error saving transactions: $e');
    }
  }

  /// Save inventory to storage
  /// Add inventory item
  Future<void> addInventoryItem(Map<String, dynamic> item) async {
    if (_useFirestore) {
      try {
        await _firestoreService.addInventoryItem(item);
        // Firestore listener will update local state
      } catch (e) {
        debugPrint('Error adding inventory to Firestore: $e');
        _inventory.add(item);
        notifyListeners();
        await _saveInventoryToStorage();
      }
    } else {
      _inventory.add(item);
      notifyListeners();
      await _saveInventoryToStorage();
    }
  }   debugPrint('Error saving inventory: $e');
    }
  }

  /// Save staff to storage
  Future<void> _saveStaffToStorage() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('staff', json.encode(_staff));
    } catch (e) {
      debugPrint('Error saving staff: $e');
    }
  /// Add staff member
  Future<void> addStaffMember(Map<String, dynamic> member) async {
    final int newId = _staff.isEmpty
        ? 1
        : _staff.map((s) => s['id'] as int).reduce((a, b) => a > b ? a : b) + 1;
    member['id'] = newId;
    
    if (_useFirestore) {
      try {
        await _firestoreService.addStaffMember(member);
        // Firestore listener will update local state
      } catch (e) {
        debugPrint('Error adding staff to Firestore: $e');
        _staff.add(member);
        notifyListeners();
        await _saveStaffToStorage();
      }
    } else {
      _staff.add(member);
      notifyListeners();
      await _saveStaffToStorage();
    }
  }

  /// Toggle Firestore sync
  void setFirestoreSync(bool enabled) {
    _useFirestore = enabled;
    if (enabled) {
      _setupFirestoreListeners();
    }
    notifyListeners();
  } }
  }

  /// Add inventory item
  Future<void> addInventoryItem(Map<String, dynamic> item) async {
    _inventory.add(item);
    notifyListeners();
    await _saveInventoryToStorage();
  }

  /// Update staff member
  Future<void> updateStaffMember(int id, Map<String, dynamic> updates) async {
    final index = _staff.indexWhere((member) => member['id'] == id);
    if (index != -1) {
      _staff[index] = {..._staff[index], ...updates};
      notifyListeners();
      await _saveStaffToStorage();
    }
  }

  /// Add staff member
  Future<void> addStaffMember(Map<String, dynamic> member) async {
    final int newId = _staff.isEmpty
        ? 1
        : _staff.map((s) => s['id'] as int).reduce((a, b) => a > b ? a : b) + 1;
    member['id'] = newId;
    _staff.add(member);
    notifyListeners();
    await _saveStaffToStorage();
  }

  /// Filter transactions by date range
  List<Transaction> getTransactionsByDateRange(DateTime start, DateTime end) {
    return _transactions.where((t) {
      final transactionDate = DateTime.parse(t.date);
      return transactionDate.isAfter(start.subtract(const Duration(days: 1))) &&
          transactionDate.isBefore(end.add(const Duration(days: 1)));
    }).toList();
  }

  /// Get transactions for today
  List<Transaction> get todayTransactions {
    final today = DateTime.now();
    final todayStr = today.toIso8601String().split('T')[0];
    return _transactions.where((t) => t.date == todayStr).toList();
  }

  /// Load KPI settings from storage
  Future<void> _loadKPISettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final String? kpiJson = prefs.getString('kpi_settings');

      if (kpiJson != null) {
        _kpiSettings = json.decode(kpiJson);
      } else {
        // Default KPI targets
        _kpiSettings = {
          'dailyRevenueTarget': 50000.0,
          'dailyTransactionsTarget': 100,
          'avgTransactionTarget': 500.0,
          'dailyExpensesTarget': 20000.0,
          'customerSatisfaction': 91.0,
          'operationalEfficiency': 88.0,
          'staffRetention': 95.0,
          'inventoryTurnover': 82.0,
          'revenueGrowth': 78.0,
        };
        await _saveKPISettings();
      }
    } catch (e) {
      debugPrint('Error loading KPI settings: $e');
    }
  }

  /// Save KPI settings to storage
  Future<void> _saveKPISettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('kpi_settings', json.encode(_kpiSettings));
    } catch (e) {
      debugPrint('Error saving KPI settings: $e');
    }
  }

  /// Update KPI setting
  Future<void> updateKPISetting(String key, dynamic value) async {
    // Ensure value is stored as double
    if (value is int) {
      _kpiSettings[key] = value.toDouble();
    } else if (value is double) {
      _kpiSettings[key] = value;
    } else {
      _kpiSettings[key] = double.tryParse(value.toString()) ?? 0.0;
    }
    notifyListeners();
    await _saveKPISettings();
  }

  /// Update multiple KPI settings
  Future<void> updateKPISettings(Map<String, dynamic> updates) async {
    updates.forEach((key, value) {
      // Ensure all values are stored as double
      if (value is int) {
        _kpiSettings[key] = value.toDouble();
      } else if (value is double) {
        _kpiSettings[key] = value;
      } else {
        _kpiSettings[key] = double.tryParse(value.toString()) ?? 0.0;
      }
    });
    notifyListeners();
    await _saveKPISettings();
  }

  /// Get KPI target value
  double getKPITarget(String key) {
    final value = _kpiSettings[key] ?? 0.0;
    if (value is int) {
      return value.toDouble();
    }
    return value as double;
  }

  /// Load tax settings from storage
  Future<void> _loadTaxSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final String? taxJson = prefs.getString('tax_settings');

      if (taxJson != null) {
        _taxSettings = json.decode(taxJson);
      } else {
        // Default tax settings
        _taxSettings = {
          'vatRate': 12.0,
          'enableVAT': true,
          'taxInclusive': false,
          'businessTIN': '',
          'businessName': '',
          'businessAddress': '',
          'zeroRatedEnabled': true,
          'vatExemptEnabled': true,
        };
        await _saveTaxSettings();
      }
    } catch (e) {
      debugPrint('Error loading tax settings: \$e');
    }
  }

  /// Save tax settings to storage
  Future<void> _saveTaxSettings() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('tax_settings', json.encode(_taxSettings));
    } catch (e) {
      debugPrint('Error saving tax settings: \$e');
    }
  }

  /// Update tax setting
  Future<void> updateTaxSetting(String key, dynamic value) async {
    _taxSettings[key] = value;
    notifyListeners();
    await _saveTaxSettings();
  }

  /// Update multiple tax settings
  Future<void> updateTaxSettings(Map<String, dynamic> updates) async {
    _taxSettings.addAll(updates);
    notifyListeners();
    await _saveTaxSettings();
  }

  /// Get tax setting value
  dynamic getTaxSetting(String key) {
    return _taxSettings[key];
  }

  /// Calculate VAT amount
  double calculateVAT(double amount, {int? vatRate}) {
    if (_taxSettings['enableVAT'] != true) return 0.0;
    final rate = vatRate ?? (_taxSettings['vatRate'] ?? 12.0);
    if (_taxSettings['taxInclusive'] == true) {
      // Tax-inclusive: VAT = amount - (amount / (1 + rate/100))
      return amount - (amount / (1 + rate / 100));
    } else {
      // Tax-exclusive: VAT = amount * (rate/100)
      return amount * (rate / 100);
    }
  }

  /// Calculate total with VAT
  double calculateTotalWithVAT(double amount, {int? vatRate}) {
    if (_taxSettings['enableVAT'] != true) return amount;
    if (_taxSettings['taxInclusive'] == true) {
      return amount; // Already includes VAT
    } else {
      final vat = calculateVAT(amount, vatRate: vatRate);
      return amount + vat;
    }
  }
}
